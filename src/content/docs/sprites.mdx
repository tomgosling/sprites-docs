---
title: Sprites
description: Create and manage persistent execution environments programmatically
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Snippet, LinkCard, CardGrid } from '@/components/react';

Sprites provides a direct interface for defining containers at runtime and securely running arbitrary code inside them.

This can be useful if, for example, you want to:

- Execute code generated by a language model
- Create isolated environments for running untrusted code
- Check out a git repository and run a command against it, like a test suite or linter
- Run containers with arbitrary dependencies and setup scripts

Each individual environment is called a **Sprite** and can be created using the CLI or SDKs:

<Tabs>
<TabItem label="CLI">
```bash
# Create a sprite
sprite create my-sprite

# Execute commands
sprite exec python -c "print('hello')"

# Stream output from long-running commands
sprite exec "for i in {1..10}; do date +%T; sleep 0.5; done"

# Destroy when done
sprite destroy my-sprite
```
</TabItem>

<TabItem label="JavaScript">
```javascript
import { SpritesClient } from '@fly/sprites';

const client = new SpritesClient(process.env.SPRITE_TOKEN);

const sprite = await client.createSprite('my-sprite');

// Execute a command
const result = await sprite.execFile('python', ['-c', "print('hello')"]);
console.log(result.stdout);

// Stream output from long-running commands
const cmd = sprite.spawn('bash', ['-c', 'for i in {1..10}; do date +%T; sleep 0.5; done']);
for await (const line of cmd.stdout) {
  process.stdout.write(line);
}

await sprite.delete();
```
</TabItem>

<TabItem label="Go">
```go
package main

import (
    "context"
    "fmt"
    "io"
    "os"

    sprites "github.com/superfly/sprites-go"
)

func main() {
    ctx := context.Background()
    client := sprites.New(os.Getenv("SPRITE_TOKEN"))

    sprite, _ := client.CreateSprite(ctx, "my-sprite", nil)
    defer client.DeleteSprite(ctx, "my-sprite")

    // Execute a command
    cmd := sprite.Command("python", "-c", "print('hello')")
    output, _ := cmd.Output()
    fmt.Println(string(output))

    // Stream output from long-running commands
    cmd = sprite.Command("bash", "-c", "for i in {1..10}; do date +%T; sleep 0.5; done")
    stdout, _ := cmd.StdoutPipe()
    cmd.Start()
    io.Copy(os.Stdout, stdout)
    cmd.Wait()
}
```
</TabItem>

<TabItem label="Elixir">
```elixir
client = Sprites.new(System.get_env("SPRITE_TOKEN"))

{:ok, sprite} = Sprites.create(client, "my-sprite")

# Execute a command
{output, 0} = Sprites.cmd(sprite, "python", ["-c", "print('hello')"])
IO.puts(output)

# Stream output from long-running commands
sprite
|> Sprites.stream("bash", ["-c", "for i in {1..10}; do date +%T; sleep 0.5; done"])
|> Stream.each(&IO.write/1)
|> Stream.run()

Sprites.destroy(sprite)
```
</TabItem>
</Tabs>

## Lifecycle

### Automatic Hibernation

Sprites automatically hibernate when inactive, with no compute charges while idle. When you execute a command or make a request to a Sprite's URL, it automatically wakes up with all your data intact.

### Timeouts

Sprites currently hibernate after **30 seconds** of inactivity. This timeout is not configurable yet.

### Idle Timeouts

A Sprite is considered active if any of the following are true:

1. It has an active command running (via `exec`)
2. Its stdin is being written to
3. It has an open TCP connection over its URL
4. A detachable session is running

## Configuration

Sprites currently use a fixed resource configuration (8 vCPUs, 8192 MB RAM, 100 GB storage). These values are not configurable yet.

### Working Directory

Set the working directory for command execution:

<Tabs>
<TabItem label="CLI">
```bash
sprite exec -dir /home/sprite/project npm test
```
</TabItem>

<TabItem label="JavaScript">
```javascript
const result = await sprite.exec('npm test', {
  cwd: '/home/sprite/project',
});
```
</TabItem>

<TabItem label="Go">
```go
cmd := sprite.Command("npm", "test")
cmd.Dir = "/home/sprite/project"
output, err := cmd.Output()
```
</TabItem>

<TabItem label="Elixir">
```elixir
{output, 0} = Sprites.cmd(sprite, "npm", ["test"],
  dir: "/home/sprite/project"
)
```
</TabItem>
</Tabs>

## Environments

### Environment Variables

Set environment variables for command execution:

<Tabs>
<TabItem label="CLI">
```bash
sprite exec -env MY_SECRET=hello bash -c 'echo $MY_SECRET'
```
</TabItem>

<TabItem label="JavaScript">
```javascript
const result = await sprite.execFile('bash', ['-lc', 'echo $MY_SECRET'], {
  env: { MY_SECRET: 'hello' },
});
console.log(result.stdout); // hello
```
</TabItem>

<TabItem label="Go">
```go
cmd := sprite.Command("bash", "-c", "echo $MY_SECRET")
cmd.Env = []string{"MY_SECRET=hello"}
output, _ := cmd.Output()
fmt.Println(string(output)) // hello
```
</TabItem>

<TabItem label="Elixir">
```elixir
{output, 0} = Sprites.cmd(sprite, "bash", ["-c", "echo $MY_SECRET"],
  env: [{"MY_SECRET", "hello"}]
)
IO.puts(output) # hello
```
</TabItem>
</Tabs>

### Pre-installed Tools

The default Sprite environment includes:

- **Languages**: Node.js, Python, Go, Ruby, Rust, Elixir/Erlang, Java, Bun, Deno
- **AI Tools**: Claude CLI, Gemini CLI, OpenAI Codex, Cursor
- **Utilities**: Git, curl, wget, vim, and common development tools

### Custom Setup

Run setup commands after creating a Sprite:

<Tabs>
<TabItem label="JavaScript">
```javascript
const sprite = await client.createSprite('my-sprite');

// Install custom dependencies
await sprite.exec('pip install pandas numpy matplotlib');
await sprite.exec('npm install -g typescript');

// Clone a repository
await sprite.exec('git clone https://github.com/your/repo.git /home/sprite/project');
```
</TabItem>

<TabItem label="Go">
```go
sprite, _ := client.CreateSprite(ctx, "my-sprite", nil)

// Install custom dependencies
sprite.Command("pip", "install", "pandas", "numpy", "matplotlib").Run()
sprite.Command("npm", "install", "-g", "typescript").Run()

// Clone a repository
sprite.Command("git", "clone", "https://github.com/your/repo.git", "/home/sprite/project").Run()
```
</TabItem>

<TabItem label="Elixir">
```elixir
{:ok, sprite} = Sprites.create(client, "my-sprite")

# Install custom dependencies
Sprites.cmd(sprite, "pip", ["install", "pandas", "numpy", "matplotlib"])
Sprites.cmd(sprite, "npm", ["install", "-g", "typescript"])

# Clone a repository
Sprites.cmd(sprite, "git", ["clone", "https://github.com/your/repo.git", "/home/sprite/project"])
```
</TabItem>
</Tabs>

## Interactive Sessions

### TTY Mode

For interactive applications, enable TTY mode:

<Tabs>
<TabItem label="CLI">
```bash
# Open interactive shell (TTY enabled by default)
sprite console

# Or with exec
sprite exec -tty bash
```
</TabItem>

<TabItem label="JavaScript">
```javascript
const cmd = sprite.spawn('bash', [], {
  tty: true,
  rows: 24,
  cols: 80,
});

// Write to stdin
cmd.stdin.write('echo hello\n');

// Read from stdout
cmd.stdout.on('data', (data) => {
  process.stdout.write(data);
});

// Resize terminal
cmd.resize(30, 100);
```
</TabItem>

<TabItem label="Go">
```go
cmd := sprite.Command("bash")
cmd.SetTTY(true)
cmd.SetTTYSize(24, 80)

cmd.Stdin = os.Stdin
cmd.Stdout = os.Stdout
cmd.Stderr = os.Stderr

cmd.Start()

// Resize later
cmd.Resize(30, 100)

cmd.Wait()
```
</TabItem>

<TabItem label="Elixir">
```elixir
{:ok, cmd} = Sprites.spawn(sprite, "bash", [],
  tty: true,
  tty_rows: 24,
  tty_cols: 80
)

# Write to stdin
Sprites.write(cmd, "echo hello\n")

# Receive output
receive do
  {:stdout, ^cmd, data} -> IO.write(data)
end

# Resize terminal
Sprites.resize(cmd, 30, 100)
```
</TabItem>
</Tabs>

### Detachable Sessions

Create sessions that persist even after disconnecting:

<Tabs>
<TabItem label="CLI">
```bash
# Create a detachable session
sprite exec -detachable "npm run dev"

# List active sessions
sprite exec

# Attach to a session
sprite exec -id <session-id>
```
</TabItem>

<TabItem label="JavaScript">
```javascript
// Create a detachable session
const sessionCmd = sprite.createSession('npm', ['run', 'dev']);
let sessionId;

sessionCmd.on('message', (msg) => {
  if (msg && msg.type === 'session_info') {
    sessionId = msg.session_id;
  }
});

// ... later, attach to it
const attachCmd = sprite.attachSession(sessionId);
attachCmd.stdout.pipe(process.stdout);
```
</TabItem>

<TabItem label="Go">
```go
// Create a detachable session
cmd := sprite.CreateDetachableSession("npm", "run", "dev")
cmd.Stdout = os.Stdout
cmd.Start()

// List sessions to get the session ID
sessions, _ := client.ListSessions(ctx, "my-sprite")
sessionID := sessions[0].ID

// ... later, attach to it
cmd = sprite.AttachSessionContext(ctx, sessionID)
cmd.Stdout = os.Stdout
cmd.Run()
```
</TabItem>

<TabItem label="Elixir">
```elixir
# Create a detachable session
{:ok, cmd} = Sprites.spawn(sprite, "npm", ["run", "dev"],
  detachable: true
)

# List sessions to get the session ID
{:ok, sessions} = Sprites.list_sessions(sprite)
session_id = List.first(sessions).id

# ... later, attach to it
{:ok, cmd} = Sprites.attach_session(sprite, session_id)
```
</TabItem>
</Tabs>

### Listing Sessions

<Tabs>
<TabItem label="CLI">
```bash
sprite exec
```
</TabItem>

<TabItem label="JavaScript">
```javascript
const sessions = await sprite.listSessions();
for (const session of sessions) {
  console.log(`${session.id}: ${session.command}`);
}
```
</TabItem>

<TabItem label="Go">
```go
sessions, _ := client.ListSessions(ctx, "my-sprite")
for _, session := range sessions {
    fmt.Printf("%s: %s\n", session.ID, session.Command)
}
```
</TabItem>

<TabItem label="Elixir">
```elixir
{:ok, sessions} = Sprites.list_sessions(sprite)
for session <- sessions do
  IO.puts("#{session.id}: #{session.command}")
end
```
</TabItem>
</Tabs>

## Referencing Sprites

### By Name

If you have the name of a Sprite, you can get a handle to it:

<Tabs>
<TabItem label="CLI">
```bash
# Set active sprite for current directory
sprite use my-sprite

# Commands now use this sprite
sprite exec echo "hello"
```
</TabItem>

<TabItem label="JavaScript">
```javascript
// Get sprite by name (doesn't verify it exists)
const sprite = client.sprite('my-sprite');

// Get sprite and verify it exists
const sprite = await client.getSprite('my-sprite');
```
</TabItem>

<TabItem label="Go">
```go
// Get sprite by name (doesn't verify it exists)
sprite := client.Sprite("my-sprite")

// Get sprite and verify it exists
sprite, err := client.GetSprite(ctx, "my-sprite")
```
</TabItem>

<TabItem label="Elixir">
```elixir
# Get sprite by name (doesn't verify it exists)
sprite = Sprites.sprite(client, "my-sprite")

# Get sprite and verify it exists
{:ok, info} = Sprites.get_sprite(client, "my-sprite")
```
</TabItem>
</Tabs>

### Listing Sprites

<Tabs>
<TabItem label="CLI">
```bash
# List all sprites
sprite list

# List with prefix filter
sprite list --prefix "dev-"
```
</TabItem>

<TabItem label="JavaScript">
```javascript
// List all sprites
const sprites = await client.listAllSprites();

// List with prefix filter
const devSprites = await client.listAllSprites('dev-');

// Paginated listing
const page = await client.listSprites({ maxResults: 50 });
console.log(page.sprites);
if (page.hasMore) {
  const nextPage = await client.listSprites({
    continuationToken: page.nextContinuationToken,
  });
}
```
</TabItem>

<TabItem label="Go">
```go
// List all sprites
sprites, _ := client.ListAllSprites(ctx, "")

// List with prefix filter
devSprites, _ := client.ListAllSprites(ctx, "dev-")

// Paginated listing
page, _ := client.ListSprites(ctx, &sprites.ListOptions{MaxResults: 50})
fmt.Println(page.Sprites)
if page.HasMore {
    nextPage, _ := client.ListSprites(ctx, &sprites.ListOptions{
        ContinuationToken: page.NextContinuationToken,
    })
}
```
</TabItem>

<TabItem label="Elixir">
```elixir
# List all sprites
{:ok, sprites} = Sprites.list(client)

# List with prefix filter
{:ok, dev_sprites} = Sprites.list(client, prefix: "dev-")
```
</TabItem>
</Tabs>

## HTTP Access

Every Sprite has a unique URL for HTTP access:

<Tabs>
<TabItem label="CLI">
```bash
# Get sprite URL
sprite url

# Make URL public (no auth required)
sprite url update --auth public

# Make URL require sprite auth (default)
sprite url update --auth default
```
</TabItem>

<TabItem label="JavaScript">
```javascript
// Get sprite info including URL
const info = await client.getSprite('my-sprite');
console.log(info.url);
```
</TabItem>

<TabItem label="Go">
```go
// Get sprite info including URL
info, _ := client.GetSprite(ctx, "my-sprite")
fmt.Println(info.URL)
```
</TabItem>

<TabItem label="Elixir">
```elixir
# Get sprite info including URL
{:ok, info} = Sprites.get_sprite(client, "my-sprite")
IO.puts(info["url"])

# Update URL settings
Sprites.update_url_settings(sprite, %{auth: "public"})
```
</TabItem>
</Tabs>

Updating URL settings is available via the CLI, Go SDK, or REST API (the JS SDK does not expose a helper yet).

## Port Forwarding

Forward local ports to your Sprite:

<Tabs>
<TabItem label="CLI">
```bash
# Forward local port 3000 to sprite port 3000
sprite proxy 3000

# Forward multiple ports
sprite proxy 3000 8080 5432
```
</TabItem>

<TabItem label="Go">
```go
// Forward single port
session, _ := client.ProxyPort(ctx, "my-sprite", 3000, 3000)
defer session.Close()
// localhost:3000 now forwards to sprite:3000

// Forward multiple ports
sessions, _ := client.ProxyPorts(ctx, "my-sprite", []sprites.PortMapping{
    {LocalPort: 3000, RemotePort: 3000},
    {LocalPort: 8080, RemotePort: 80},
})
```
</TabItem>

<TabItem label="Elixir">
```elixir
# Forward single port
{:ok, session} = Sprites.proxy_port(sprite, 3000, 3000)
# localhost:3000 now forwards to sprite:3000

# Forward multiple ports
mappings = [
  %Sprites.Proxy.PortMapping{local_port: 3000, remote_port: 3000},
  %Sprites.Proxy.PortMapping{local_port: 8080, remote_port: 80}
]
{:ok, sessions} = Sprites.proxy_ports(sprite, mappings)
```
</TabItem>
</Tabs>

### Port Notifications

Get notified when ports open in your Sprite:

<Tabs>
<TabItem label="JavaScript">
```javascript
const cmd = sprite.spawn('npm', ['run', 'dev']);

cmd.on('message', (msg) => {
  if (msg.type === 'port_opened') {
    console.log(`Port ${msg.port} opened on ${msg.address} by PID ${msg.pid}`);
    // Auto-forward or notify user
  }
});
```
</TabItem>

<TabItem label="Go">
```go
cmd := sprite.Command("npm", "run", "dev")
cmd.TextMessageHandler = func(data []byte) {
    var notification sprites.PortNotificationMessage
    json.Unmarshal(data, &notification)

    if notification.Type == "port_opened" {
        fmt.Printf("Port %d opened on %s by PID %d\n", notification.Port, notification.Address, notification.PID)
    }
}
cmd.Run()
```
</TabItem>

<TabItem label="Elixir">
```elixir
{:ok, cmd} = Sprites.spawn(sprite, "npm", ["run", "dev"], tty: true)

receive do
  {:port, ^cmd, port} ->
    IO.puts("Port #{port} opened")
  {:stdout, ^cmd, data} ->
    IO.write(data)
end
```
</TabItem>
</Tabs>

## Checkpoints

Save and restore Sprite state:

<Tabs>
<TabItem label="CLI">
```bash
# Create a checkpoint
sprite checkpoint create

# List checkpoints
sprite checkpoint list

# Restore from checkpoint
sprite restore <checkpoint-id>
```
</TabItem>
</Tabs>

See [Checkpoints and Restore](/concepts/checkpoints) for more details.

## Error Handling

<Tabs>
<TabItem label="JavaScript">
```javascript
import { ExecError } from '@fly/sprites';

try {
  await sprite.execFile('bash', ['-lc', 'exit 1']);
} catch (error) {
  if (error instanceof ExecError) {
    console.log('Exit code:', error.exitCode);
    console.log('Stdout:', error.stdout);
    console.log('Stderr:', error.stderr);
  }
}
```
</TabItem>

<TabItem label="Go">
```go
cmd := sprite.Command("bash", "-lc", "exit 1")
err := cmd.Run()

if err != nil {
    if exitErr, ok := err.(*sprites.ExitError); ok {
        fmt.Printf("Exit code: %d\n", exitErr.ExitCode())
    }
}
```
</TabItem>

<TabItem label="Elixir">
```elixir
case Sprites.cmd(sprite, "bash", ["-lc", "exit 1"]) do
  {_output, 0} ->
    IO.puts("Success")
  {_output, exit_code} ->
    IO.puts("Exit code: #{exit_code}")
end

# Or with async commands
{:ok, cmd} = Sprites.spawn(sprite, "bash", ["-lc", "exit 1"])
receive do
  {:exit, ^cmd, code} -> IO.puts("Exit code: #{code}")
  {:error, ^cmd, reason} -> IO.inspect(reason)
end
```
</TabItem>
</Tabs>

## Cleanup

Always clean up Sprites when you're done:

<Tabs>
<TabItem label="CLI">
```bash
sprite destroy my-sprite
```
</TabItem>

<TabItem label="JavaScript">
```javascript
await sprite.delete();
// or
await client.deleteSprite('my-sprite');
```
</TabItem>

<TabItem label="Go">
```go
err := client.DeleteSprite(ctx, "my-sprite")
```
</TabItem>

<TabItem label="Elixir">
```elixir
:ok = Sprites.destroy(sprite)
```
</TabItem>
</Tabs>

## Related Documentation

<CardGrid client:load>
  <LinkCard
    href="/concepts/lifecycle"
    title="Lifecycle and Persistence"
    description="Understand sprite states, hibernation, and automatic persistence"
    icon="layers"
    client:load
  />
  <LinkCard
    href="/concepts/networking"
    title="Networking and URLs"
    description="Access sprites via HTTP and configure network settings"
    icon="zap"
    client:load
  />
  <LinkCard
    href="/concepts/checkpoints"
    title="Checkpoints"
    description="Save and restore sprite state with checkpoints"
    icon="folder"
    client:load
  />
  <LinkCard
    href="/sdks/javascript"
    title="JavaScript SDK"
    description="Programmatic sprite management in JavaScript and TypeScript"
    icon="code"
    client:load
  />
  <LinkCard
    href="/sdks/go"
    title="Go SDK"
    description="Native Go client for the Sprites API"
    icon="code"
    client:load
  />
  <LinkCard
    href="/sdks/elixir"
    title="Elixir SDK"
    description="Idiomatic Elixir client with Stream support"
    icon="code"
    client:load
  />
  <LinkCard
    href="/cli/commands"
    title="CLI Reference"
    description="Complete command-line interface documentation"
    icon="terminal"
    client:load
  />
</CardGrid>
